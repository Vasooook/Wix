<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Globe</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        svg { display: block; width: 100vw; height: 100vh; }
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="tooltip" class="tooltip"></div>
    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        const projection = d3.geoOrthographic()
            .scale(250)
            .translate([width / 2, height / 2])
            .clipAngle(90);

        const path = d3.geoPath().projection(projection);

        const tooltip = d3.select("#tooltip");

        // Добавляем интерактивный слой для вращения глобуса
        let v0, r0, q0;

        svg.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged));

        function dragstarted(event) {
            v0 = versor.cartesian(projection.invert([event.x, event.y]));
            r0 = projection.rotate();
            q0 = versor(r0);
        }

        function dragged(event) {
            const v1 = versor.cartesian(projection.invert([event.x, event.y]));
            const q1 = versor.multiply(q0, versor.delta(v0, v1));
            projection.rotate(versor.rotation(q1));
            svg.selectAll("path").attr("d", path);
        }

        // Загружаем данные карты мира
        d3.json("https://d3js.org/world-110m.v1.json").then(world => {
            svg.append("path")
                .datum(topojson.feature(world, world.objects.land))
                .attr("fill", "#ccc")
                .attr("d", path);

            svg.append("path")
                .datum(topojson.mesh(world, world.objects.countries, (a, b) => a !== b))
                .attr("fill", "none")
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .attr("d", path);
        });

        // Функция для отображения информации при наведении
        svg.selectAll("path")
            .on("mouseover", function(event, d) {
                tooltip.style("display", "block");
                tooltip.html("Country: " + d.properties.name);
                tooltip.style("left", (event.pageX + 10) + "px");
                tooltip.style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", function() {
                tooltip.style("display", "none");
            });

        // Функции Versor для вращения
        const versor = {
            cartesian([λ, φ]) {
                return [Math.cos(φ) * Math.cos(λ), Math.cos(φ) * Math.sin(λ), Math.sin(φ)];
            },
            rotation([λ, φ, γ]) {
                return [λ * 180 / Math.PI, φ * 180 / Math.PI, γ * 180 / Math.PI];
            },
            delta(v0, v1) {
                const v = this.cross(v0, v1), l = this.length(v);
                return l ? [Math.asin(l), v[2], -v[1], v[0]] : [0, 1, 0, 0];
            },
            multiply([a, b, c, d], [e, f, g, h]) {
                return [
                    a * e - b * f - c * g - d * h,
                    a * f + b * e + c * h - d * g,
                    a * g - b * h + c * e + d * f,
                    a * h + b * g - c * f + d * e
                ];
            },
            cross([x0, y0, z0], [x1, y1, z1]) {
                return [y0 * z1 - z0 * y1, z0 * x1 - x0 * z1, x0 * y1 - y0 * x1];
            },
            length([x, y, z]) {
                return Math.sqrt(x * x + y * y + z * z);
            }
        };
    </script>
</body>
</html>
